import math
import functools
import asyncio
from discord.ext import commands

class ImageConverter(commands.Converter):
    async def convert(self, ctx, argument=None):
        try:
            argument = argument.removesuffix('\U0000fe0f')
            url = f"http://twemoji.maxcdn.com/v/latest/72x72/{format(ord(argument), 'x')}.png"
            return url
        except Exception:
            try:
                e = await commands.PartialEmojiConverter().convert(ctx, argument)
                return str(e.url)
            except Exception:
                try:
                    u = await commands.MemberConverter().convert(ctx, argument)
                    return u.avatar.url
                except Exception:
                    return str(argument.strip("<>"))

class FontConverter(commands.Converter):
    async def convert(self, ctx, text):
        alphabet = dict(zip("abcdefghijklmnopqrstuvwxyz1234567890", range(0, 36)))
        uppercase_alphabet = dict(zip("ABCDEFGHIJKLMNOPQRSTUVWXYZ", range(0, 26)))
        punctuation = dict(zip("Â§Â½!\"#Â¤%&/()=?`Â´@Â£$â‚¬{[]}\\^Â¨~'*<>|,.-_:", range(0, 37)))
        space = " "

        textdict = {
            "aesthetic_uppercase": "ï¼¡ï¼¢ï¼£ï¼¤ï¼¥ï¼¦ï¼§ï¼¨ï¼©ï¼ªï¼«ï¼¬ï¼­ï¼®ï¼¯ï¼°ï¼±ï¼²ï¼³ï¼´ï¼µï¼¶ï¼·ï¼¸ï¼¹ï¼º",
            "aesthetic_lowercase": "ï½ï½‚ï½ƒï½„ï½…ï½†ï½‡ï½ˆï½‰ï½Šï½‹ï½Œï½ï½ï½ï½ï½‘ï½’ï½“ï½”ï½•ï½–ï½—ï½˜ï½™ï½šï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™ï¼",
            "aesthetic_space": "\u3000",
            "aesthetic_punctuation": "Â§Â½ï¼\"ï¼ƒÂ¤ï¼…ï¼†ï¼ï¼ˆï¼‰ï¼ï¼Ÿ`Â´ï¼ Â£ï¼„â‚¬ï½›ï¼»ï¼½ï½ï¼¼ï¼¾Â¨~ï¼‡ï¼Šï¼œï¼|ï¼Œï¼ï¼ï¼¿ï¼š",
            "fraktur_uppercase": "ğ”„ğ”…â„­ğ”‡ğ”ˆğ”‰ğ”Šâ„Œâ„‘ğ”ğ”ğ”ğ”ğ”‘ğ”’ğ”“ğ””â„œğ”–ğ”—ğ”˜ğ”™ğ”šğ”›ğ”œâ„¨",
            "fraktur_lowercase": "ğ”ğ”Ÿğ” ğ”¡ğ”¢ğ”£ğ”¤ğ”¥ğ”¦ğ”§ğ”¨ğ”©ğ”ªğ”«ğ”¬ğ”­ğ”®ğ”¯ğ”°ğ”±ğ”²ğ”³ğ”´ğ”µğ”¶ğ”·1234567890",
            "boldfaktur_uppercase": "ğ•¬ğ•­ğ•®ğ•¯ğ•°ğ•±ğ•²ğ•³ğ•´ğ•µğ•¶ğ•·ğ•¸ğ•¹ğ•ºğ•»ğ•¼ğ•½ğ•¾ğ•¿ğ–€ğ–ğ–‚ğ–ƒğ–„ğ–…",
            "boldfaktur_lowercase": "ğ–†ğ–‡ğ–ˆğ–‰ğ–Šğ–‹ğ–Œğ–ğ–ğ–ğ–ğ–‘ğ–’ğ–“ğ–”ğ–•ğ––ğ–—ğ–˜ğ–™ğ–šğ–›ğ–œğ–ğ–ğ–Ÿ1234567890",
            "fancy_uppercase": "ğ’œğµğ’ğ’Ÿğ¸ğ¹ğ’¢ğ»ğ¼ğ’¥ğ’¦ğ¿ğ‘€ğ’©ğ’ªğ’«ğ’¬ğ‘…ğ’®ğ’¯ğ’°ğ’±ğ’²ğ’³ğ’´ğ’µ",
            "fancy_lowercase": "ğ’¶ğ’·ğ’¸ğ’¹ğ‘’ğ’»ğ‘”ğ’½ğ’¾ğ’¿ğ“€ğ“ğ“‚ğ“ƒğ‘œğ“…ğ“†ğ“‡ğ“ˆğ“‰ğ“Šğ“‹ğ“Œğ“ğ“ğ“ğŸ£ğŸ¤ğŸ¥ğŸ¦ğŸ§ğŸ¨ğŸ©ğŸªğŸ«ğŸ¢",
            "boldfancy_uppercase": "ğ“ğ“‘ğ“’ğ““ğ“”ğ“•ğ“–ğ“—ğ“˜ğ“™ğ“šğ“›ğ“œğ“ğ“ğ“Ÿğ“ ğ“¡ğ“¢ğ“£ğ“¤ğ“¥ğ“¦ğ“§ğ“¨ğ“©",
            "boldfancy_lowercase": "ğ“ªğ“«ğ“¬ğ“­ğ“®ğ“¯ğ“°ğ“±ğ“²ğ“³ğ“´ğ“µğ“¶ğ“·ğ“¸ğ“¹ğ“ºğ“»ğ“¼ğ“½ğ“¾ğ“¿ğ”€ğ”ğ”‚ğ”ƒ1234567890",
            "double_uppercase": "ğ”¸ğ”¹â„‚ğ”»ğ”¼ğ”½ğ”¾â„ğ•€ğ•ğ•‚ğ•ƒğ•„â„•ğ•†â„™â„šâ„ğ•Šğ•‹ğ•Œğ•ğ•ğ•ğ•â„¤",
            "double_lowercase": "ğ•’ğ•“ğ•”ğ••ğ•–ğ•—ğ•˜ğ•™ğ•šğ•›ğ•œğ•ğ•ğ•Ÿğ• ğ•¡ğ•¢ğ•£ğ•¤ğ•¥ğ•¦ğ•§ğ•¨ğ•©ğ•ªğ•«ğŸ™ğŸšğŸ›ğŸœğŸğŸğŸŸğŸ ğŸ¡ğŸ˜",
            "smallcaps_uppercase": "á´€Ê™á´„á´…á´‡êœ°É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜Ç«Ê€êœ±á´›á´œá´ á´¡xÊá´¢1234567890",
            "smallcaps_lowercase": "á´€Ê™á´„á´…á´‡êœ°É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜Ç«Ê€êœ±á´›á´œá´ á´¡xÊá´¢1234567890"
        }

        uppercase_font = textdict[f"{ctx.command.name}_uppercase"]
        lowercase_font = textdict[f"{ctx.command.name}_lowercase"]

        converted = ""

        for word in text:
            for letter in word:
                if letter in alphabet:
                    converted += lowercase_font[alphabet[letter]]
                elif letter in uppercase_alphabet:
                    converted += uppercase_font[uppercase_alphabet[letter]]
                elif letter in punctuation:
                    if (p := f"{ctx.command.name}_punctuation") in textdict.keys():
                        converted += textdict[p]
                    else:
                        converted += letter
                elif letter == space:
                    if (s := f"{ctx.command.name}_space") in textdict.keys():
                        converted += textdict[s]
                    else:
                        converted += " "
                else:
                    converted += letter

        return converted

def readable_bytes(size_bytes):
    if size_bytes == 0:
        return "0B"
    size_name = ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
    i = int(math.floor(math.log(size_bytes, 1024)))
    p = math.pow(1024, i)
    s = float(size_bytes / p)
    return f"{s:.2f}{size_name[i]}"

def executor(sync_function):
    @functools.wraps(sync_function)
    async def sync_wrapper(*args, **kwargs):
        loop = asyncio.get_event_loop()
        internal_function = functools.partial(sync_function, *args, **kwargs)
        return await loop.run_in_executor(None, internal_function)
    return sync_wrapper